package hostmetrics

import (
	"fmt"
	"path"
	"strings"
	"time"

	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// AddElasticK8sMetrics computes additional metrics for compatibility with the Elastic system integration.
// The `scopeMetrics` input should be metrics generated by a specific hostmetrics scraper.
// `scopeMetrics` are modified in place.
func AddElasticK8sMetrics(scopeMetrics pmetric.ScopeMetrics, resource pcommon.Resource, storage map[string]any) error {
	scope := scopeMetrics.Scope()
	group := path.Base(scope.Name())

	currentTime := time.Now().UnixMilli()
	if lastScrape, ok := storage["lastScrape"]; ok {
		collectionPeriod := currentTime - lastScrape.(int64)
		scopeMetrics.Scope().Attributes().PutDouble("metricset.period", float64(collectionPeriod))
	}
	storage["lastScrape"] = currentTime

	switch group {
	case "kubeletstatsreceiver":
		return addkubeletMetrics(scopeMetrics.Metrics(), resource, group)
	// case "container":
	// 	return addContainerMetrics(scopeMetrics.Metrics(), resource, dataset)
	// case "pod":
	// 	return addPodMetrics(scopeMetrics.Metrics(), resource, dataset)
	// case "node":
	// 	return addNodeMetrics(scopeMetrics.Metrics(), resource, dataset)
	default:
		return fmt.Errorf("no matching transform function found for scope '%s'", scope.Name())
	}
}

// addDatastream calculates the datastream_dataset name of the metric based on the name of the metric provided
func addDatastream(name string, group string) string {
	splitted_metric := strings.Split(name, ".")
	datastream := ""
	prefix := "kubernetes"

	if splitted_metric[0] == "kubernetes" {
		switch splitted_metric[1] {
		case "pod":
			datastream = "pod"
		case "container":
			datastream = "container"
		case "node":
			datastream = "node"
		}
	}

	if group == "kubeletstatsreceiver" {
		datastream = prefix + "." + datastream
	} else if group == "k8sclusterreceiver" {
		datastream = prefix + ".state_" + datastream
	}

	return datastream
}
